// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gameProto.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_gameProto_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_gameProto_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_gameProto_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_gameProto_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_gameProto_2eproto;
namespace lspb {
class BGameFrame;
class BGameFrameDefaultTypeInternal;
extern BGameFrameDefaultTypeInternal _BGameFrame_default_instance_;
class BGameInit;
class BGameInitDefaultTypeInternal;
extern BGameInitDefaultTypeInternal _BGameInit_default_instance_;
class BGameStart;
class BGameStartDefaultTypeInternal;
extern BGameStartDefaultTypeInternal _BGameStart_default_instance_;
class CliEnterRoom;
class CliEnterRoomDefaultTypeInternal;
extern CliEnterRoomDefaultTypeInternal _CliEnterRoom_default_instance_;
class CliInitOver;
class CliInitOverDefaultTypeInternal;
extern CliInitOverDefaultTypeInternal _CliInitOver_default_instance_;
class CliOperate;
class CliOperateDefaultTypeInternal;
extern CliOperateDefaultTypeInternal _CliOperate_default_instance_;
class PlayerInfo;
class PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
class SrvEnterRoom;
class SrvEnterRoomDefaultTypeInternal;
extern SrvEnterRoomDefaultTypeInternal _SrvEnterRoom_default_instance_;
class SrvInitOver;
class SrvInitOverDefaultTypeInternal;
extern SrvInitOverDefaultTypeInternal _SrvInitOver_default_instance_;
}  // namespace lspb
PROTOBUF_NAMESPACE_OPEN
template<> ::lspb::BGameFrame* Arena::CreateMaybeMessage<::lspb::BGameFrame>(Arena*);
template<> ::lspb::BGameInit* Arena::CreateMaybeMessage<::lspb::BGameInit>(Arena*);
template<> ::lspb::BGameStart* Arena::CreateMaybeMessage<::lspb::BGameStart>(Arena*);
template<> ::lspb::CliEnterRoom* Arena::CreateMaybeMessage<::lspb::CliEnterRoom>(Arena*);
template<> ::lspb::CliInitOver* Arena::CreateMaybeMessage<::lspb::CliInitOver>(Arena*);
template<> ::lspb::CliOperate* Arena::CreateMaybeMessage<::lspb::CliOperate>(Arena*);
template<> ::lspb::PlayerInfo* Arena::CreateMaybeMessage<::lspb::PlayerInfo>(Arena*);
template<> ::lspb::SrvEnterRoom* Arena::CreateMaybeMessage<::lspb::SrvEnterRoom>(Arena*);
template<> ::lspb::SrvInitOver* Arena::CreateMaybeMessage<::lspb::SrvInitOver>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace lspb {

// ===================================================================

class CliEnterRoom PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lspb.CliEnterRoom) */ {
 public:
  inline CliEnterRoom() : CliEnterRoom(nullptr) {};
  virtual ~CliEnterRoom();

  CliEnterRoom(const CliEnterRoom& from);
  CliEnterRoom(CliEnterRoom&& from) noexcept
    : CliEnterRoom() {
    *this = ::std::move(from);
  }

  inline CliEnterRoom& operator=(const CliEnterRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline CliEnterRoom& operator=(CliEnterRoom&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CliEnterRoom& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CliEnterRoom* internal_default_instance() {
    return reinterpret_cast<const CliEnterRoom*>(
               &_CliEnterRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CliEnterRoom& a, CliEnterRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(CliEnterRoom* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CliEnterRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CliEnterRoom* New() const final {
    return CreateMaybeMessage<CliEnterRoom>(nullptr);
  }

  CliEnterRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CliEnterRoom>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CliEnterRoom& from);
  void MergeFrom(const CliEnterRoom& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CliEnterRoom* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lspb.CliEnterRoom";
  }
  protected:
  explicit CliEnterRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_gameProto_2eproto);
    return ::descriptor_table_gameProto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kRoomIdFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 roomId = 1;
  void clear_roomid();
  ::PROTOBUF_NAMESPACE_ID::int32 roomid() const;
  void set_roomid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_roomid() const;
  void _internal_set_roomid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:lspb.CliEnterRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 roomid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gameProto_2eproto;
};
// -------------------------------------------------------------------

class SrvEnterRoom PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lspb.SrvEnterRoom) */ {
 public:
  inline SrvEnterRoom() : SrvEnterRoom(nullptr) {};
  virtual ~SrvEnterRoom();

  SrvEnterRoom(const SrvEnterRoom& from);
  SrvEnterRoom(SrvEnterRoom&& from) noexcept
    : SrvEnterRoom() {
    *this = ::std::move(from);
  }

  inline SrvEnterRoom& operator=(const SrvEnterRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline SrvEnterRoom& operator=(SrvEnterRoom&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SrvEnterRoom& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SrvEnterRoom* internal_default_instance() {
    return reinterpret_cast<const SrvEnterRoom*>(
               &_SrvEnterRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SrvEnterRoom& a, SrvEnterRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(SrvEnterRoom* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SrvEnterRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SrvEnterRoom* New() const final {
    return CreateMaybeMessage<SrvEnterRoom>(nullptr);
  }

  SrvEnterRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SrvEnterRoom>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SrvEnterRoom& from);
  void MergeFrom(const SrvEnterRoom& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SrvEnterRoom* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lspb.SrvEnterRoom";
  }
  protected:
  explicit SrvEnterRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_gameProto_2eproto);
    return ::descriptor_table_gameProto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // int32 playerId = 1;
  void clear_playerid();
  ::PROTOBUF_NAMESPACE_ID::int32 playerid() const;
  void set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_playerid() const;
  void _internal_set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:lspb.SrvEnterRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 playerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gameProto_2eproto;
};
// -------------------------------------------------------------------

class BGameInit PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lspb.BGameInit) */ {
 public:
  inline BGameInit() : BGameInit(nullptr) {};
  virtual ~BGameInit();

  BGameInit(const BGameInit& from);
  BGameInit(BGameInit&& from) noexcept
    : BGameInit() {
    *this = ::std::move(from);
  }

  inline BGameInit& operator=(const BGameInit& from) {
    CopyFrom(from);
    return *this;
  }
  inline BGameInit& operator=(BGameInit&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BGameInit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BGameInit* internal_default_instance() {
    return reinterpret_cast<const BGameInit*>(
               &_BGameInit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BGameInit& a, BGameInit& b) {
    a.Swap(&b);
  }
  inline void Swap(BGameInit* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BGameInit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BGameInit* New() const final {
    return CreateMaybeMessage<BGameInit>(nullptr);
  }

  BGameInit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BGameInit>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BGameInit& from);
  void MergeFrom(const BGameInit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BGameInit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lspb.BGameInit";
  }
  protected:
  explicit BGameInit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_gameProto_2eproto);
    return ::descriptor_table_gameProto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPListFieldNumber = 2,
    kSeedFieldNumber = 1,
  };
  // repeated .lspb.PlayerInfo pList = 2;
  int plist_size() const;
  private:
  int _internal_plist_size() const;
  public:
  void clear_plist();
  ::lspb::PlayerInfo* mutable_plist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lspb::PlayerInfo >*
      mutable_plist();
  private:
  const ::lspb::PlayerInfo& _internal_plist(int index) const;
  ::lspb::PlayerInfo* _internal_add_plist();
  public:
  const ::lspb::PlayerInfo& plist(int index) const;
  ::lspb::PlayerInfo* add_plist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lspb::PlayerInfo >&
      plist() const;

  // int32 seed = 1;
  void clear_seed();
  ::PROTOBUF_NAMESPACE_ID::int32 seed() const;
  void set_seed(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_seed() const;
  void _internal_set_seed(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:lspb.BGameInit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lspb::PlayerInfo > plist_;
  ::PROTOBUF_NAMESPACE_ID::int32 seed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gameProto_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lspb.PlayerInfo) */ {
 public:
  inline PlayerInfo() : PlayerInfo(nullptr) {};
  virtual ~PlayerInfo();

  PlayerInfo(const PlayerInfo& from);
  PlayerInfo(PlayerInfo&& from) noexcept
    : PlayerInfo() {
    *this = ::std::move(from);
  }

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
               &_PlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PlayerInfo& a, PlayerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerInfo* New() const final {
    return CreateMaybeMessage<PlayerInfo>(nullptr);
  }

  PlayerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerInfo& from);
  void MergeFrom(const PlayerInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lspb.PlayerInfo";
  }
  protected:
  explicit PlayerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_gameProto_2eproto);
    return ::descriptor_table_gameProto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
    kStartPointFieldNumber = 3,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 playerId = 1;
  void clear_playerid();
  ::PROTOBUF_NAMESPACE_ID::int32 playerid() const;
  void set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_playerid() const;
  void _internal_set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 startPoint = 3;
  void clear_startpoint();
  ::PROTOBUF_NAMESPACE_ID::int32 startpoint() const;
  void set_startpoint(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_startpoint() const;
  void _internal_set_startpoint(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:lspb.PlayerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 playerid_;
  ::PROTOBUF_NAMESPACE_ID::int32 startpoint_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gameProto_2eproto;
};
// -------------------------------------------------------------------

class CliInitOver PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lspb.CliInitOver) */ {
 public:
  inline CliInitOver() : CliInitOver(nullptr) {};
  virtual ~CliInitOver();

  CliInitOver(const CliInitOver& from);
  CliInitOver(CliInitOver&& from) noexcept
    : CliInitOver() {
    *this = ::std::move(from);
  }

  inline CliInitOver& operator=(const CliInitOver& from) {
    CopyFrom(from);
    return *this;
  }
  inline CliInitOver& operator=(CliInitOver&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CliInitOver& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CliInitOver* internal_default_instance() {
    return reinterpret_cast<const CliInitOver*>(
               &_CliInitOver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CliInitOver& a, CliInitOver& b) {
    a.Swap(&b);
  }
  inline void Swap(CliInitOver* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CliInitOver* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CliInitOver* New() const final {
    return CreateMaybeMessage<CliInitOver>(nullptr);
  }

  CliInitOver* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CliInitOver>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CliInitOver& from);
  void MergeFrom(const CliInitOver& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CliInitOver* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lspb.CliInitOver";
  }
  protected:
  explicit CliInitOver(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_gameProto_2eproto);
    return ::descriptor_table_gameProto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:lspb.CliInitOver)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gameProto_2eproto;
};
// -------------------------------------------------------------------

class SrvInitOver PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lspb.SrvInitOver) */ {
 public:
  inline SrvInitOver() : SrvInitOver(nullptr) {};
  virtual ~SrvInitOver();

  SrvInitOver(const SrvInitOver& from);
  SrvInitOver(SrvInitOver&& from) noexcept
    : SrvInitOver() {
    *this = ::std::move(from);
  }

  inline SrvInitOver& operator=(const SrvInitOver& from) {
    CopyFrom(from);
    return *this;
  }
  inline SrvInitOver& operator=(SrvInitOver&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SrvInitOver& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SrvInitOver* internal_default_instance() {
    return reinterpret_cast<const SrvInitOver*>(
               &_SrvInitOver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SrvInitOver& a, SrvInitOver& b) {
    a.Swap(&b);
  }
  inline void Swap(SrvInitOver* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SrvInitOver* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SrvInitOver* New() const final {
    return CreateMaybeMessage<SrvInitOver>(nullptr);
  }

  SrvInitOver* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SrvInitOver>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SrvInitOver& from);
  void MergeFrom(const SrvInitOver& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SrvInitOver* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lspb.SrvInitOver";
  }
  protected:
  explicit SrvInitOver(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_gameProto_2eproto);
    return ::descriptor_table_gameProto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:lspb.SrvInitOver)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gameProto_2eproto;
};
// -------------------------------------------------------------------

class BGameStart PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lspb.BGameStart) */ {
 public:
  inline BGameStart() : BGameStart(nullptr) {};
  virtual ~BGameStart();

  BGameStart(const BGameStart& from);
  BGameStart(BGameStart&& from) noexcept
    : BGameStart() {
    *this = ::std::move(from);
  }

  inline BGameStart& operator=(const BGameStart& from) {
    CopyFrom(from);
    return *this;
  }
  inline BGameStart& operator=(BGameStart&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BGameStart& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BGameStart* internal_default_instance() {
    return reinterpret_cast<const BGameStart*>(
               &_BGameStart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BGameStart& a, BGameStart& b) {
    a.Swap(&b);
  }
  inline void Swap(BGameStart* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BGameStart* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BGameStart* New() const final {
    return CreateMaybeMessage<BGameStart>(nullptr);
  }

  BGameStart* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BGameStart>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BGameStart& from);
  void MergeFrom(const BGameStart& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BGameStart* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lspb.BGameStart";
  }
  protected:
  explicit BGameStart(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_gameProto_2eproto);
    return ::descriptor_table_gameProto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:lspb.BGameStart)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gameProto_2eproto;
};
// -------------------------------------------------------------------

class BGameFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lspb.BGameFrame) */ {
 public:
  inline BGameFrame() : BGameFrame(nullptr) {};
  virtual ~BGameFrame();

  BGameFrame(const BGameFrame& from);
  BGameFrame(BGameFrame&& from) noexcept
    : BGameFrame() {
    *this = ::std::move(from);
  }

  inline BGameFrame& operator=(const BGameFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline BGameFrame& operator=(BGameFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BGameFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BGameFrame* internal_default_instance() {
    return reinterpret_cast<const BGameFrame*>(
               &_BGameFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BGameFrame& a, BGameFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(BGameFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BGameFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BGameFrame* New() const final {
    return CreateMaybeMessage<BGameFrame>(nullptr);
  }

  BGameFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BGameFrame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BGameFrame& from);
  void MergeFrom(const BGameFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BGameFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lspb.BGameFrame";
  }
  protected:
  explicit BGameFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_gameProto_2eproto);
    return ::descriptor_table_gameProto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperListFieldNumber = 2,
    kFIdFieldNumber = 1,
  };
  // repeated .lspb.CliOperate operList = 2;
  int operlist_size() const;
  private:
  int _internal_operlist_size() const;
  public:
  void clear_operlist();
  ::lspb::CliOperate* mutable_operlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lspb::CliOperate >*
      mutable_operlist();
  private:
  const ::lspb::CliOperate& _internal_operlist(int index) const;
  ::lspb::CliOperate* _internal_add_operlist();
  public:
  const ::lspb::CliOperate& operlist(int index) const;
  ::lspb::CliOperate* add_operlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lspb::CliOperate >&
      operlist() const;

  // int32 fId = 1;
  void clear_fid();
  ::PROTOBUF_NAMESPACE_ID::int32 fid() const;
  void set_fid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_fid() const;
  void _internal_set_fid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:lspb.BGameFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lspb::CliOperate > operlist_;
  ::PROTOBUF_NAMESPACE_ID::int32 fid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gameProto_2eproto;
};
// -------------------------------------------------------------------

class CliOperate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lspb.CliOperate) */ {
 public:
  inline CliOperate() : CliOperate(nullptr) {};
  virtual ~CliOperate();

  CliOperate(const CliOperate& from);
  CliOperate(CliOperate&& from) noexcept
    : CliOperate() {
    *this = ::std::move(from);
  }

  inline CliOperate& operator=(const CliOperate& from) {
    CopyFrom(from);
    return *this;
  }
  inline CliOperate& operator=(CliOperate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CliOperate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CliOperate* internal_default_instance() {
    return reinterpret_cast<const CliOperate*>(
               &_CliOperate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CliOperate& a, CliOperate& b) {
    a.Swap(&b);
  }
  inline void Swap(CliOperate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CliOperate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CliOperate* New() const final {
    return CreateMaybeMessage<CliOperate>(nullptr);
  }

  CliOperate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CliOperate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CliOperate& from);
  void MergeFrom(const CliOperate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CliOperate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lspb.CliOperate";
  }
  protected:
  explicit CliOperate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_gameProto_2eproto);
    return ::descriptor_table_gameProto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirectionFieldNumber = 1,
    kIsFireFieldNumber = 2,
    kPlayerIdFieldNumber = 3,
  };
  // string direction = 1;
  void clear_direction();
  const std::string& direction() const;
  void set_direction(const std::string& value);
  void set_direction(std::string&& value);
  void set_direction(const char* value);
  void set_direction(const char* value, size_t size);
  std::string* mutable_direction();
  std::string* release_direction();
  void set_allocated_direction(std::string* direction);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_direction();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_direction(
      std::string* direction);
  private:
  const std::string& _internal_direction() const;
  void _internal_set_direction(const std::string& value);
  std::string* _internal_mutable_direction();
  public:

  // bool isFire = 2;
  void clear_isfire();
  bool isfire() const;
  void set_isfire(bool value);
  private:
  bool _internal_isfire() const;
  void _internal_set_isfire(bool value);
  public:

  // int32 playerId = 3;
  void clear_playerid();
  ::PROTOBUF_NAMESPACE_ID::int32 playerid() const;
  void set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_playerid() const;
  void _internal_set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:lspb.CliOperate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr direction_;
  bool isfire_;
  ::PROTOBUF_NAMESPACE_ID::int32 playerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gameProto_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CliEnterRoom

// int32 roomId = 1;
inline void CliEnterRoom::clear_roomid() {
  roomid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CliEnterRoom::_internal_roomid() const {
  return roomid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CliEnterRoom::roomid() const {
  // @@protoc_insertion_point(field_get:lspb.CliEnterRoom.roomId)
  return _internal_roomid();
}
inline void CliEnterRoom::_internal_set_roomid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  roomid_ = value;
}
inline void CliEnterRoom::set_roomid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:lspb.CliEnterRoom.roomId)
}

// string name = 2;
inline void CliEnterRoom::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& CliEnterRoom::name() const {
  // @@protoc_insertion_point(field_get:lspb.CliEnterRoom.name)
  return _internal_name();
}
inline void CliEnterRoom::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:lspb.CliEnterRoom.name)
}
inline std::string* CliEnterRoom::mutable_name() {
  // @@protoc_insertion_point(field_mutable:lspb.CliEnterRoom.name)
  return _internal_mutable_name();
}
inline const std::string& CliEnterRoom::_internal_name() const {
  return name_.Get();
}
inline void CliEnterRoom::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CliEnterRoom::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:lspb.CliEnterRoom.name)
}
inline void CliEnterRoom::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:lspb.CliEnterRoom.name)
}
inline void CliEnterRoom::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:lspb.CliEnterRoom.name)
}
inline std::string* CliEnterRoom::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CliEnterRoom::release_name() {
  // @@protoc_insertion_point(field_release:lspb.CliEnterRoom.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CliEnterRoom::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:lspb.CliEnterRoom.name)
}
inline std::string* CliEnterRoom::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lspb.CliEnterRoom.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CliEnterRoom::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lspb.CliEnterRoom.name)
}

// -------------------------------------------------------------------

// SrvEnterRoom

// int32 playerId = 1;
inline void SrvEnterRoom::clear_playerid() {
  playerid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SrvEnterRoom::_internal_playerid() const {
  return playerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SrvEnterRoom::playerid() const {
  // @@protoc_insertion_point(field_get:lspb.SrvEnterRoom.playerId)
  return _internal_playerid();
}
inline void SrvEnterRoom::_internal_set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  playerid_ = value;
}
inline void SrvEnterRoom::set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:lspb.SrvEnterRoom.playerId)
}

// -------------------------------------------------------------------

// BGameInit

// int32 seed = 1;
inline void BGameInit::clear_seed() {
  seed_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGameInit::_internal_seed() const {
  return seed_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGameInit::seed() const {
  // @@protoc_insertion_point(field_get:lspb.BGameInit.seed)
  return _internal_seed();
}
inline void BGameInit::_internal_set_seed(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  seed_ = value;
}
inline void BGameInit::set_seed(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_seed(value);
  // @@protoc_insertion_point(field_set:lspb.BGameInit.seed)
}

// repeated .lspb.PlayerInfo pList = 2;
inline int BGameInit::_internal_plist_size() const {
  return plist_.size();
}
inline int BGameInit::plist_size() const {
  return _internal_plist_size();
}
inline void BGameInit::clear_plist() {
  plist_.Clear();
}
inline ::lspb::PlayerInfo* BGameInit::mutable_plist(int index) {
  // @@protoc_insertion_point(field_mutable:lspb.BGameInit.pList)
  return plist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lspb::PlayerInfo >*
BGameInit::mutable_plist() {
  // @@protoc_insertion_point(field_mutable_list:lspb.BGameInit.pList)
  return &plist_;
}
inline const ::lspb::PlayerInfo& BGameInit::_internal_plist(int index) const {
  return plist_.Get(index);
}
inline const ::lspb::PlayerInfo& BGameInit::plist(int index) const {
  // @@protoc_insertion_point(field_get:lspb.BGameInit.pList)
  return _internal_plist(index);
}
inline ::lspb::PlayerInfo* BGameInit::_internal_add_plist() {
  return plist_.Add();
}
inline ::lspb::PlayerInfo* BGameInit::add_plist() {
  // @@protoc_insertion_point(field_add:lspb.BGameInit.pList)
  return _internal_add_plist();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lspb::PlayerInfo >&
BGameInit::plist() const {
  // @@protoc_insertion_point(field_list:lspb.BGameInit.pList)
  return plist_;
}

// -------------------------------------------------------------------

// PlayerInfo

// int32 playerId = 1;
inline void PlayerInfo::clear_playerid() {
  playerid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerInfo::_internal_playerid() const {
  return playerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerInfo::playerid() const {
  // @@protoc_insertion_point(field_get:lspb.PlayerInfo.playerId)
  return _internal_playerid();
}
inline void PlayerInfo::_internal_set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  playerid_ = value;
}
inline void PlayerInfo::set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:lspb.PlayerInfo.playerId)
}

// string name = 2;
inline void PlayerInfo::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& PlayerInfo::name() const {
  // @@protoc_insertion_point(field_get:lspb.PlayerInfo.name)
  return _internal_name();
}
inline void PlayerInfo::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:lspb.PlayerInfo.name)
}
inline std::string* PlayerInfo::mutable_name() {
  // @@protoc_insertion_point(field_mutable:lspb.PlayerInfo.name)
  return _internal_mutable_name();
}
inline const std::string& PlayerInfo::_internal_name() const {
  return name_.Get();
}
inline void PlayerInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PlayerInfo::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:lspb.PlayerInfo.name)
}
inline void PlayerInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:lspb.PlayerInfo.name)
}
inline void PlayerInfo::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:lspb.PlayerInfo.name)
}
inline std::string* PlayerInfo::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PlayerInfo::release_name() {
  // @@protoc_insertion_point(field_release:lspb.PlayerInfo.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PlayerInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:lspb.PlayerInfo.name)
}
inline std::string* PlayerInfo::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lspb.PlayerInfo.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void PlayerInfo::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lspb.PlayerInfo.name)
}

// int32 startPoint = 3;
inline void PlayerInfo::clear_startpoint() {
  startpoint_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerInfo::_internal_startpoint() const {
  return startpoint_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerInfo::startpoint() const {
  // @@protoc_insertion_point(field_get:lspb.PlayerInfo.startPoint)
  return _internal_startpoint();
}
inline void PlayerInfo::_internal_set_startpoint(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  startpoint_ = value;
}
inline void PlayerInfo::set_startpoint(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_startpoint(value);
  // @@protoc_insertion_point(field_set:lspb.PlayerInfo.startPoint)
}

// -------------------------------------------------------------------

// CliInitOver

// -------------------------------------------------------------------

// SrvInitOver

// -------------------------------------------------------------------

// BGameStart

// -------------------------------------------------------------------

// BGameFrame

// int32 fId = 1;
inline void BGameFrame::clear_fid() {
  fid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGameFrame::_internal_fid() const {
  return fid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BGameFrame::fid() const {
  // @@protoc_insertion_point(field_get:lspb.BGameFrame.fId)
  return _internal_fid();
}
inline void BGameFrame::_internal_set_fid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  fid_ = value;
}
inline void BGameFrame::set_fid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_fid(value);
  // @@protoc_insertion_point(field_set:lspb.BGameFrame.fId)
}

// repeated .lspb.CliOperate operList = 2;
inline int BGameFrame::_internal_operlist_size() const {
  return operlist_.size();
}
inline int BGameFrame::operlist_size() const {
  return _internal_operlist_size();
}
inline void BGameFrame::clear_operlist() {
  operlist_.Clear();
}
inline ::lspb::CliOperate* BGameFrame::mutable_operlist(int index) {
  // @@protoc_insertion_point(field_mutable:lspb.BGameFrame.operList)
  return operlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lspb::CliOperate >*
BGameFrame::mutable_operlist() {
  // @@protoc_insertion_point(field_mutable_list:lspb.BGameFrame.operList)
  return &operlist_;
}
inline const ::lspb::CliOperate& BGameFrame::_internal_operlist(int index) const {
  return operlist_.Get(index);
}
inline const ::lspb::CliOperate& BGameFrame::operlist(int index) const {
  // @@protoc_insertion_point(field_get:lspb.BGameFrame.operList)
  return _internal_operlist(index);
}
inline ::lspb::CliOperate* BGameFrame::_internal_add_operlist() {
  return operlist_.Add();
}
inline ::lspb::CliOperate* BGameFrame::add_operlist() {
  // @@protoc_insertion_point(field_add:lspb.BGameFrame.operList)
  return _internal_add_operlist();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lspb::CliOperate >&
BGameFrame::operlist() const {
  // @@protoc_insertion_point(field_list:lspb.BGameFrame.operList)
  return operlist_;
}

// -------------------------------------------------------------------

// CliOperate

// string direction = 1;
inline void CliOperate::clear_direction() {
  direction_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& CliOperate::direction() const {
  // @@protoc_insertion_point(field_get:lspb.CliOperate.direction)
  return _internal_direction();
}
inline void CliOperate::set_direction(const std::string& value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:lspb.CliOperate.direction)
}
inline std::string* CliOperate::mutable_direction() {
  // @@protoc_insertion_point(field_mutable:lspb.CliOperate.direction)
  return _internal_mutable_direction();
}
inline const std::string& CliOperate::_internal_direction() const {
  return direction_.Get();
}
inline void CliOperate::_internal_set_direction(const std::string& value) {
  
  direction_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CliOperate::set_direction(std::string&& value) {
  
  direction_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:lspb.CliOperate.direction)
}
inline void CliOperate::set_direction(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  direction_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:lspb.CliOperate.direction)
}
inline void CliOperate::set_direction(const char* value,
    size_t size) {
  
  direction_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:lspb.CliOperate.direction)
}
inline std::string* CliOperate::_internal_mutable_direction() {
  
  return direction_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CliOperate::release_direction() {
  // @@protoc_insertion_point(field_release:lspb.CliOperate.direction)
  return direction_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CliOperate::set_allocated_direction(std::string* direction) {
  if (direction != nullptr) {
    
  } else {
    
  }
  direction_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), direction,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:lspb.CliOperate.direction)
}
inline std::string* CliOperate::unsafe_arena_release_direction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lspb.CliOperate.direction)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return direction_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CliOperate::unsafe_arena_set_allocated_direction(
    std::string* direction) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (direction != nullptr) {
    
  } else {
    
  }
  direction_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      direction, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lspb.CliOperate.direction)
}

// bool isFire = 2;
inline void CliOperate::clear_isfire() {
  isfire_ = false;
}
inline bool CliOperate::_internal_isfire() const {
  return isfire_;
}
inline bool CliOperate::isfire() const {
  // @@protoc_insertion_point(field_get:lspb.CliOperate.isFire)
  return _internal_isfire();
}
inline void CliOperate::_internal_set_isfire(bool value) {
  
  isfire_ = value;
}
inline void CliOperate::set_isfire(bool value) {
  _internal_set_isfire(value);
  // @@protoc_insertion_point(field_set:lspb.CliOperate.isFire)
}

// int32 playerId = 3;
inline void CliOperate::clear_playerid() {
  playerid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CliOperate::_internal_playerid() const {
  return playerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CliOperate::playerid() const {
  // @@protoc_insertion_point(field_get:lspb.CliOperate.playerId)
  return _internal_playerid();
}
inline void CliOperate::_internal_set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  playerid_ = value;
}
inline void CliOperate::set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:lspb.CliOperate.playerId)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace lspb

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_gameProto_2eproto
